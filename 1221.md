# Object.prototype에 열거 가능한 프로퍼티를 절대 추가하지 마라

우리는 앞서 Object가 모든 프로토타입 체인의 가장 상위에 존재하는 것을 배웠다. <br />
따라서 `Object.prototype`에 프로퍼티를 추가한다는 것은 모든 객체가 공유할 수 있는 프로퍼티라는 뜻이다.<br />

`for...in`문은 순회하는 객체의 프로퍼티뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다. <br />
즉, 프로토타입 체인의 가장 상위에 있는 Object의 프로퍼티까지 전부 열거한다는 뜻이다.<br />
이는 프로토타입을 오염시키기 쉬운데, 예를 들어 다음과 같은 객체의 프로퍼티 이름을 배열로 생성해주는 allKeys 메서드를 추가한다고 가정해보자.<br />

```
Object.prototype.allKeys = function() {
  var result = [];
  for (var key in this) {
    result.push(key);
  }
  return result;
}

({a : 1, b : 2, c : 3}).allKeys(); // ["allKeys", "a", "b", "c"]
```

이렇듯 폭넓게 공유된 프로토타입 객체(여기서는 `Object.prototype`)에 가한 행위는 그 객체의 사용자에게 영향을 미친다. <br />
`Object.prototype`에 하나의 작은 프로퍼티를 추가하기만 해도, 누구든지 어디서든지 `for...in` 반복문을 사용할 수 없게 되었다.<br />

가장 간단한 해결 방법으로는 allKeys를 `Object.prototype`의 메서드가 아니라 그냥 함수로 정의하는 것이다.<br />
또 다른 방법으로 ES5는 `Object.defineProperty` 메서드라는 더 협조적인 메커니즘을 제공한다. <br />

프로퍼티 어트리뷰트 [[Enumerable]] 는 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. <br />
따라서 열거 가능한 프로퍼티란 [[Enumerable]] 값이 true인 항목을 말하고, 위 예제에서 보았듯이 사용자가 확장하는 속성은 `enumerable` 명세가 기본적으로 true이다.<br />
표준 내장 객체의 기본 속성 혹은 prototype 속성들은 대부분 enumerable : false로 지정되어 있기 때문에 `for...in`을 통해 열거되지 않는다.<br />
이때, 사용자는 `Object.defineProperty` 메서드를 통해 `enumerable` 속성을 false로 지정할 수 있다.<br />

```
Object.defineProperty(Object.prototype, "allKeys", {
  value: function() {
    var result = [];
    for (var key in this) {
      result.push(key);
    }
    return result;
  },
  writable : true,
  enumerable : false,
  configurable : true,
});
```

이 코드는 길고 복잡하지만, 이 버전의 코드는 다른 모든 Object의 인스턴스에 대한 for...in 반복문을 오염시키지 않는다는 확실한 이점이 있다.<br />
`Object.defineProperty`는 Object 뿐만 아니라 폭넓게 공유되는 프로토타입 객체에서 for...in 반복문에서 보이고 싶지 않은 프로퍼티를 추가하기 위해 사용하기도 좋다.<br />

### 결론
- `Object.prototype`에 프로퍼티를 추가하지 마라.
- `Object.prototype`에 메서드를 작성하는 대신 함수를 고려하라.
- `Object.prototype`에 프로퍼티를 추가한다면, ES5의 `Object.defineProperty`를 사용하여 열거할 수 없는 프로퍼티로 정의하라.

<br />

# 열거하는 동안 객체를 수정하지 마라

- for...in 반복문으로 객체의 프로퍼티를 열거하는 동안 객체를 수정하지 마라.
- 반복분 내에서 내용이 변경될 수 있는 객체를 반복할 때는 for...in 대신 while이나 전통적인 for 반복문을 사용하라.
- 데이터 구조가 변경될 수도 있는 열거에는, 딕셔너리 객체 대신에 배열 같은 순차적인 데이터 구조의 사용을 고려하라.

<br />

# 배열을 반복할 때 for...in 대신 for 반복문을 사용하라

```
var scores = [98, 74, 85, 77, 93, 100, 89];
var total = 0;
for (var score in scores) {
  total += score;
}
var mean = total /scores.length;
mean; // ?
```

이 코드에서 mean의 값은 무엇일까? 만약 scores의 평균 값인 88을 생각했다면 코드의 의도는 이해한 게 맞지만, 실제 결과값은 아니다.
이 코드는 숫자로 된 배열의 키와 값을 헷갈리는 실수를 저질렀다. `for...in` 반복문은 항상 키를 열거한다. 
그렇다면 (0 + 1 + ... + 6) / 7 = 21 이 될 수 있지만, 이 역시도 틀렸다. 배열의 인덱싱된 프로퍼티일지라도 **객체의 프로퍼티 키는 항상 문자열**임을 기억해야 한다.
따라서 += 연산자는 문자열 병합을 일으키고, 의도치 않은 합계는 "00123456"이 된다. 

배열의 내용을 반복하기 위한 적절한 방법은 전통적인 for 반복문을 사용하는 것이다.

```

```

### for...of

`for...of` 반복문은 ES6에 추가된 새로운 컬렉션 전용 반복 구문이다. 
여기서 컬렉션이란 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것들을 말한다.
`for...in`의 경우 객체의 모든 열거 가능한 속성에 대해 반복했다면, `for...of`는 [symbol.iterator] 속성을 가지는 컬렉션 전용이다. 


# 반복문 대신 반복 메서드를 사용하라

반복 메서드 대부분은 첫 번째 인수로 함수의 참조를 받는 고차 함수이다.

# 유사 배열 객체에 범용적인 배열 메서드를 재사용하라

유사 배열이란? 
