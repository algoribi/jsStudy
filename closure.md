# 호이스팅(Hoisting)

> 인터프리터가 변수와 함수를 선언 전에 메모리 공간을 미리 할당하는 것

- 아래에 선언된 변수와 함수가 코드 최상단에 위치하는 것처럼 동작. (실제로 코드가 끌어올려지는 건 아니다.)
- **선언**만 위로 끌어올려지며, **초기화, 할당**은 끌어올려지지 않는다. (= var와 함수 선언문만 호이스팅이 유효한 이유)

```
console.log(name);

var name = 'Mike';
```

위의 코드는 에러를 출력하지 않는다. 변수의 선언은 호이스팅 되기 때문이다.
따라서 위의 코드는 다음과 같이 동작한다.

```
var name;

console.log(name); // undefined

name = 'Mike';
```

호이스팅은 **선언**만 끌어올려지고, 초기화와 할당은 끌어올려지지 않는다.
그럼에도 name이 undefined로 출력되는 이유는, var의 경우 할당 전에 호출하면 자동으로 undefined로 초기화해주기 때문이다.

호이스팅은 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동해주기 때문에, 사실상 let과 const도 호이스팅 된다고 할 수 있다.
다만 let과 const의 경우 var처럼 자동으로 초기화해주지 않기 때문에, 호이스팅 되어도 사용할 수 없는 것이다.
이게 ES6에서 var대신 let과 const 사용을 권장하는 이유이며, 이는 코드를 예측 가능하게 하고, 잠재적인 버그를 줄일 수 있다.

같은 이유로 함수 표현식에서는 선언과 할당이 분리돼서 이뤄지기 때문에, 함수 선언문은 호이스팅 되지만 함수 표현식은 호이스팅되지 않는다.

<br />

# 클로저(Closure)

- JS는 정적 스코프(static scope)를 채택한다. 이는 함수가 정의되는 위치에 따라 참조할 수 있는 변수의 유효 범위가 달라지는 것을 의미하며, 어휘적 환경(lexical environment)라고도 한다.
  - 함수를 호출하는 위치에 따라 참조할 수 있는 변수의 유효 범위가 달라지는 것은 동적 스코프(dynamic scope)라고 한다.

다음과 같은 코드가 있을 때

```
function makeAdder(x) {
    return function(y) {
        return x + y;
    }
}

let add3 = makeAdder(3);
console.log(add3(2));
```

1. 최초 실행 시 호이스팅에 의해 전역 Lexical 환경은 다음과 같아진다.

```
// 전역 lexical 환경
makeAdder : function
add3 : 초기화x(사용 불가능한 상태)
```

2. let add3 = makeAdder(3); 구문이 실행될 때 makeAdder 함수가 실행되고 makeAdder Lexical 환경이 만들어진다.
   함수의 lexical 환경에는 넘겨받은 매개변수와 지역변수들이 저장된다. 따라서 이곳에 전달받은 x의 값이 들어간다.

```
// makeAdder lexical 환경
x : 3
```

동시에 전역 lexical 환경에서 add3의 값은 makeAdder가 return한 익명 함수가 들어간다.

```
// 전역 lexical 환경
makeAdder : function
add3 : function
```

3. 코드의 마지막 줄인 console.log(add3(2)); 를 실행하면 add3에 할당된 익명함수가 실행되면서 익명함수 lexical 환경이 만들어진다.
   동시에 y는 2로 초기화된다.

```
// 익명함수 lexical 환경
y : 2
```

이제, x + y를 실행시키기 위해 변수를 찾는다. 이때, 익명함수의 lexical 환경은 makeAdder 환경을 **참조**하고 있고, makeAdder는 전역 lexical환경을 참조하고 있다.
따라서 익명함수의 lexical환경에서 y를 찾고, x를 찾지 못했다면 참조하고 있는 상위 lexical 환경에서 이 값을 찾는다.
따라서 console.log(add3(2));는 5를 출력한다.

이처럼 함수가 생성될 당시의 외부 변수를 기억하고, 생성 이후에도 계속 접근이 가능하도록 함수와 함수가 선언된 lexical 환경의 조합을 closure라고 한다.

closure는 위의 예제에서 본 것처럼 외부 변수에 대한 **참조**를 저장하고 있기 때문에 이 값들에 대해 읽고 갱신할 수 있다.

```
function makeCounter() {
    let num = 0;
    return function () {
        return num++;
    }
}

let counter = makeCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2
```

이 예제에서 makeCounter는 let counter에 익명함수를 return해주고 끝이 났다. 그렇지만 클로저에 의해 익명함수 외부 변수인 num값의 참조를 가지고 있기 때문에 이 값을 계속 읽고, 갱신할 수 있다.

이처럼 클로저는 자신을 생성한 함수보다 더 오래 지속될 수 있다.

<br />

## 지역 변수 스코프를 만들기 위해 즉시 실행 함수 표현식을 사용하라

```
function wrapElements(a) {
    var result = [], i, n;
    for (i = 0, n = a.length; i < n; i++) {
        result[i] = function() { return a[i]; };
    }
    return result;
}

var wrapped = wrapElements([10, 20, 30, 40, 50]);
var f = wrapped[0];
f(); // ?
```

이 코드에서 프로그래머는 10이라는 값을 계산할 의도로 코드를 작성했겠지만, wrapped[0]에는 undefined 값이 들어가 있다. 왜냐하면 i는 5라는 값을 가지고 있기 때문이다.

wrapped에는 익명함수 `function() { return a[i]; };`가 반복문이 반복한 수만큼 배열로 들어가 있고, 이 각각의 익명 함수들은 클로저를 가지고 있는데, 앞선 장에서 봤듯이 클로저는 외부 변수를 **참조**하고 있기 때문에, 반복문이 동작하는 동안 외부 변수 i는 값이 증가했고 최종적으로 5라는 값을 가지고 있기 때문이다. 따라서 입력으로 받은 배열의 index 5의 값은 없기 때문에 undefined를 출력한다.

따라서 이 경우 원래의 의도대로 코드를 동작하게 하고 싶다면 **즉시 실행 함수 표현식(IIFE)으로 감싸서 강제로 지역 스코프를 만들어 주면 된다.**

```
function wrapElements(a) {
    var result = [], i, n;
    for (i = 0, n = a.length; i < n; i++) {
        (function() {
            var j = i;
            result[i] = function() = { return a[j]; };
        })();
    }
    return result;
}
```

이렇게 되면, 즉시 실행 함수 표현식(IIFE)에 의해 j는 호출된 시점에서 바로 초기화될 것이고, 우리는 원래 의도한 인덱스에 접근할 수 있을 것이다.
단, IIFE로 감싸진 함수, 변수들은 클로저로 인해 모두 블록 바깥으로 영향을 줄 수 없다. 따라서 위의 코드에서 IIFE에서 break나 continue 등의 명령어를 사용해 for문을 중단하는 행동은 할 수 없을 것이다.

<br />

## 기명 함수 표현식의 스코프에 주의하라

- JS에서 함수는 값으로 취급되며, 함수의 자료형은 **객체**이다. 따라서 우리는 함수를 호출할 수 있을 뿐만 아니라 객체처럼 함수에 프포퍼티를 추가, 제거하거나 참조를 통해 전달할 수 있다.
- 함수 표현식은 정의한 function을 별도의 변수에 할당하는 것이기 때문에 함수명이 있어도 되고, 없어도 된다.
  - 함수명을 정의하지 않은 함수 표현식을 **익명 함수 표현식**이라고 한다.
  - 함수명을 정의한 함수 표현식을 **기명 함수 표현식**이라고 한다.

```
// 익명 함수 표현식
var a = function() { ... };
b(); // 실행 OK

// 기명 함수 표현식
var b = function c() { ... };
b(); // 실행 OK
c(); // Error!!
```

이처럼 기명 함수의 경우 외부에서는 함수명으로 함수를 호출할 수 없다. 함수명은 오직 함수 내부에서만 접근이 가능하다.
따라서 위의 예제에서 c함수 내부에서는 d()로 재귀 호출이 가능하다. 다만, c()로도 재귀 호출은 가능하기 때문에 이것이 기명 함수의 필요성이 될 수는 없다.

> 기명 함수 표현식 어디에 쓸까?

과거에는 익명함수의 이름을 로그에서 확인할 수 없었기 때문에 기명 함수를 통해 디버깅을 하면서 어떤 함수인지 추적을 했다고 한다.
하지만 모던 브라우저에서는 name 프로퍼티를 확인할 수 있도록 지원하고 있다.

> 결론은 기명 함수 표현식을 사용해서 특별히 얻을 수 있는 득이 없다.

더불어 사용하지 말아야 할 이유는 많다. 결론적으로는 **기명 함수 표현식의 사용을 자제하고, 배포하기 전에 제거해야 한다.**

다음으로는 기명 함수 표현식을 사용하는데 주의해야하는 이유이다.

```
- ES3와 버그가 있는 JS 실행 환경에서 함수 표현식이 스코프를 Object.prototype으로 오염시킨다는 점을 주의해야 한다.
- 버그가 있는 JS 실행 환경에서 기명 함수 표현식의 호이스팅과 중복 할당을 주의해야 한다.
```

[더 자세한 설명](https://wit.nts-corp.com/2013/12/05/554)

<br />

## 블록-지역 함수 선언문의 스코프에 주의하라

다음과 같은 코드가 있다.

```
function f() { return "global"; };
function test(x) {
    var result = [];
    if (x) {
        function f() { return "local"; }; // 지역 블록
        result.push(f());
    }
    result.push(f());
    return result;
}
test(true); // ?
test(false); // ?
```

내부의 f함수는 if 블록에 지역적으로 나타나기 때문에, test(true)를 호출하면 ["local", "global"]을 반환하고, test(false)를 호출하면 ["global"]을 반환할까?<br />
아니면 함수 선언문은 앞서 **호이스팅**된다고 배웠기 때문에 지역 블록의 f함수로 오버라이딩되어 ["local", "local"]과 ["local"]을 반환할까?<br />

정답은 실행 환경에 따라 달라진다.
놀랍게도 ES5 이전까지의 표준에서는 블록 단위에서 나타나는 지역 함수 선언문의 존재조차 알지 못했다고 한다.
함수 선언문은 공식적으로 다른 함수나 프로그램의 가장 바깥 레벨에서만 나타날 수 있다고 기술되어 있다.
따라서 ES5에서는 비표준 문맥으로 사용되는 함수 선언문을 주의나 오류로 표시하기를 권한다.

결론적으로 **함수 선언문은 지역 블록이나 하위 명령에 절대 두지 않아야 한다.**
또한 조건적인 상황에서 함수의 사용이 필요하다면 함수 선언문 대신 함수 표현식을 사용한다.
